% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/access.R
\name{createAccessExpression.default}
\alias{createAccessExpression.default}
\title{Create access expression}
\usage{
\method{createAccessExpression}{default}(inst, idx = character(),
  value = NULL, name_obj = "inst", name_value = "value",
  evaluate = FALSE, sugar = c("[[", "$"), as_name_obj = TRUE,
  as_name_value = FALSE, eval_in_parent = FALSE,
  return_conventional = TRUE, ...)
}
\arguments{
\item{inst}{\code{\link[base]{list}}.
TODO}

\item{idx}{\code{\link[base]{character}}.
TODO}

\item{value}{\code{ANY} (\code{\link[methods]{BasicClasses}}).
Optional assignment value.}

\item{name_obj}{\code{\link[base]{character}}.
Name of the actual object in the expression that values are extracted from
or assigned to.}

\item{name_value}{\code{\link[base]{character}}.
TODO}

\item{evaluate}{\code{\link[base]{logical}}.
TODO}

\item{sugar}{\code{\link[base]{character}}.
Syntactic sugar function to use.}

\item{as_name_obj}{\code{\link[base]{logical}}.
TODO}

\item{as_name_value}{\code{\link[base]{logical}}.
TODO}

\item{eval_in_parent}{\code{\link[base]{logical}}.
TODO}

\item{return_conventional}{\code{\link[base]{logical}}.
Only relevant if \code{!is.null(value)}. Return conventional return value
of assignments via \code{<-} or more plausible information in typical
contexts where this functions might be used. These are:
\itemize{
  \item{updated object \code{inst} if \code{eval_in_parent = FALSE}}
  \item{\code{NULL} if \code{eval_in_parent = TRUE} in order to stress the
  point that an object has been altered in the parent frame}
}}

\item{...}{Further arguments to be passed to subsequent functions/methods.}
}
\value{
\code{\link[base]{expression}} or evaluated get expression
 if \code{evaluate = TRUE}. Exact value also depends on
 \code{return_conventional}
 (in interaction with \code{value} and \code{eval_in_parent})
}
\description{
Default method of \code{\link[crudr]{createAccessExpression}}.
}
\details{
TODO
}
\examples{

# Example object ----------------------------------------------------------

inst <- list(a = list(b = list(c = 10)))

# Extract -----------------------------------------------------------------

createAccessExpression(inst, c("a", "b"))

createAccessExpression(inst, c("a", "b"), evaluate = TRUE)
## --> evaluated inside the function

createAccessExpression(inst, c("a", "b"), evaluate = TRUE, eval_in_parent = TRUE)
## --> evaluated in the frame of `inst`

# Assign ------------------------------------------------------------------

createAccessExpression(inst, c("a", "b", "c"), 100)
createAccessExpression(inst, c("a", "b", "c"), 100, evaluate = TRUE)
## --> evaluated inside the function
inst
## --> `inst$a$b$c` still is `10`

createAccessExpression(inst, c("a", "b", "c"), 100, evaluate = TRUE,
  eval_in_parent = TRUE)
## --> evaluated in the frame of `inst`
inst
## --> `inst$a$b$c` is now `100`

# Return values -----------------------------------------------------------

inst <- list(a = list(b = list(c = 10)))

createAccessExpression(inst, c("a", "b", "c"), 100, evaluate = TRUE,
  return_conventional = FALSE)
## --> evaluated inside the function and entire "updated" object `inst`returned
inst
## --> `inst$a$b$c` still is `10`

createAccessExpression(inst, c("a", "b", "c"), 1, evaluate = TRUE,
  eval_in_parent = TRUE, return_conventional = FALSE)
## --> evaluated in the frame of `inst`. In this case, `NULL` is returned
##     in order to stress the point that the actual object being altered
##     has nothing to do with the return value
inst
## --> `inst$a$b$c` is now `1`

# Sugar = $ ---------------------------------------------------------------

## For the sake of completeness the function also allows you to use the
## syntactic sugar `$` instead of `[[`. While this might be usefull in
## certain usage scenarios, it needs to be noted that comes with additional
## computiational costs (see benchmark)

inst <- list(a = list(b = list(c = 10)))
createAccessExpression(inst, c("a", "b"), sugar = "$")
createAccessExpression(inst, c("a", "b"), value = 1, sugar = "$")

library(microbenchmark)
res <- microbenchmark(
  "extract_1" = createAccessExpression(inst, c("a", "b"), sugar = "[["),
  "extract_2" = createAccessExpression(inst, c("a", "b"), sugar = "$"),
  "assign_1" = createAccessExpression(inst, c("a", "b"), 1, sugar = "[["),
  "assign_2" = createAccessExpression(inst, c("a", "b"), 1, sugar = "$")
)
res

# Comparison to plain method ----------------------------------------------

## While `createAccessExpression` offers more features,
## `createAccessExpressionPlain` is substantially faster.

library(microbenchmark)
res <- microbenchmark(
  "extract_1" = createAccessExpression(inst, c("a", "b")),
  "extract_2" = createAccessExpressionPlain(inst, c("a", "b")),
  "assign_1" = createAccessExpression(inst, c("a", "b"), 1),
  "assign_2" = createAccessExpressionPlain(inst, c("a", "b"), 1)
)
res
}
\author{
Janko Thyson \email{janko.thyson@rappster.de}
}
\references{
\url{http://github.com/rappster/crudr}
}
\seealso{
\code{\link[crudr]{createAccessExpression}}
}

