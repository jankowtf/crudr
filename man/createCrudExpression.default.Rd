% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crud.R
\name{createCrudExpression.default}
\alias{createCrudExpression.default}
\title{Create CRUD expression}
\usage{
\method{createCrudExpression}{default}(inst, id = character(), value = NULL,
  name_obj = "inst", name_value = "value", as_name_obj = TRUE,
  as_name_value = FALSE, evaluate = FALSE, sugar = c("[[", "$"),
  in_parent = FALSE, return_conventional = TRUE, strict = 0:3,
  fail_safe = FALSE, use_tree = FALSE, allow_null = FALSE,
  affect_branch = FALSE, ...)
}
\arguments{
\item{inst}{\code{\link[base]{list}}.
TODO}

\item{id}{\code{\link[base]{character}}.
TODO}

\item{value}{\code{ANY} (\code{\link[methods]{BasicClasses}}).
Optional assignment value.}

\item{name_obj}{\code{\link[base]{character}}.
Name of the actual object in the expression that values are extracted from
or assigned to.}

\item{name_value}{\code{\link[base]{character}}.
TODO}

\item{as_name_obj}{\code{\link[base]{logical}}.
TODO}

\item{as_name_value}{\code{\link[base]{logical}}.
TODO}

\item{evaluate}{\code{\link[base]{logical}}.
TODO}

\item{sugar}{\code{\link[base]{character}}.
Syntactic sugar function to use.}

\item{in_parent}{\code{\link[base]{logical}}.
TODO}

\item{return_conventional}{\code{\link[base]{logical}}.
Only relevant if \code{!is.null(value)}. Return conventional return value
of assignments via \code{<-} or more plausible information in typical
contexts where this functions might be used. These are:
\itemize{
  \item{updated object \code{inst} if \code{in_parent = FALSE}}
  \item{\code{NULL} if \code{in_parent = TRUE} in order to stress the
  point that an object has been altered in the parent frame}
}}

\item{strict}{\code{\link[base]{numeric}}.
Strictness levels:
\itemize{
  \item{0: }{no condition is signaled}
  \item{1: }{message is signaled}
  \item{2: }{warning is signaled}
  \item{3: }{error is signaled}
}}

\item{fail_safe}{\code{\link[base]{logical}}.
Wrap with \code{\link[base]{try}}.}

\item{use_tree}{\code{\link[base]{logical}}.
Use expression tree as returned by
  \code{\link[crudr]{createCrudExpressionTree}}.}

\item{allow_null}{\code{\link[base]{logical}}.
Allows \code{value = NULL}. Useful for deleting values.}

\item{affect_branch}{\code{\link[base]{logical}}.
Only relevant when \code{value = NULL} in which case a value will be
deleted. Unless we use \code{use_tree = TRUE}, the function has no means
of distinguishing the provided \code{id} belongs to a branch or a leaf in
the hierarchy. Setting this to \code{TRUE} will delete the entire branch
while \code{FALSE} will keep the branch with a value of
\code{structure(list(), names = character())}.}

\item{...}{Further arguments to be passed to subsequent functions/methods.}
}
\value{
\code{\link[base]{expression}} or evaluated CRUD expression
 if \code{evaluate = TRUE}. Exact value also depends on
 \code{return_conventional}
 (in interaction with \code{value} and \code{in_parent})
}
\description{
Default method of \code{\link[crudr]{createCrudExpression}}.
}
\details{
TODO
}
\examples{

# Example object ----------------------------------------------------------

inst <- list(a = list(b = list(c = 10)))

# Extract -----------------------------------------------------------------

createCrudExpression(inst, c("a", "b"))

createCrudExpression(inst, c("a", "b"), evaluate = TRUE)
## --> evaluated inside the function

createCrudExpression(inst, c("a", "b"), evaluate = TRUE, in_parent = TRUE)
## --> evaluated in the frame of `inst`

# Assign ------------------------------------------------------------------

createCrudExpression(inst, c("a", "b", "c"), 100)
createCrudExpression(inst, c("a", "b", "c"), 100, evaluate = TRUE)
## --> evaluated inside the function
inst
## --> `inst$a$b$c` still is `10`

createCrudExpression(inst, c("a", "b", "c"), 100, evaluate = TRUE,
  in_parent = TRUE)
## --> evaluated in the frame of `inst`
inst
## --> `inst$a$b$c` is now `100`

# Return values -----------------------------------------------------------

inst <- list(a = list(b = list(c = 10)))

createCrudExpression(inst, c("a", "b", "c"), 100, evaluate = TRUE,
  return_conventional = FALSE)
## --> evaluated inside the function and entire "updated" object `inst`returned
inst
## --> `inst$a$b$c` still is `10`

createCrudExpression(inst, c("a", "b", "c"), 1, evaluate = TRUE,
  in_parent = TRUE, return_conventional = FALSE)
## --> evaluated in the frame of `inst`. In this case, `NULL` is returned
##     in order to stress the point that the actual object being altered
##     has nothing to do with the return value
inst
## --> `inst$a$b$c` is now `1`

# Sugar = $ ---------------------------------------------------------------

## For the sake of completeness the function also allows you to use the
## syntactic sugar `$` instead of `[[`. While this might be usefull in
## certain usage scenarios, it needs to be noted that comes with additional
## computiational costs (see benchmark)

inst <- list(a = list(b = list(c = 10)))
createCrudExpression(inst, c("a", "b"), sugar = "$")
createCrudExpression(inst, c("a", "b"), value = 1, sugar = "$")

library(microbenchmark)
res <- microbenchmark(
  "extract_1" = createCrudExpression(inst, c("a", "b"), sugar = "[["),
  "extract_2" = createCrudExpression(inst, c("a", "b"), sugar = "$"),
  "assign_1" = createCrudExpression(inst, c("a", "b"), 1, sugar = "[["),
  "assign_2" = createCrudExpression(inst, c("a", "b"), 1, sugar = "$")
)
res

# Comparison to plain method ----------------------------------------------

## While `createCrudExpression` offers more features,
## `createCrudExpressionPlain` is substantially faster.

library(microbenchmark)
res <- microbenchmark(
  "extract_1" = createCrudExpression(inst, c("a", "b")),
  "extract_2" = createCrudExpressionPlain(inst, c("a", "b")),
  "assign_1" = createCrudExpression(inst, c("a", "b"), 1),
  "assign_2" = createCrudExpressionPlain(inst, c("a", "b"), 1)
)
res


# Bridging ----------------------------------------------------------------

inst <- list(a = list(b = 1))
createCrudExpression(inst, c("a", "b", "c", "d"), value = 1, evaluate = TRUE,
  return_conventional = FALSE)
createCrudExpression(inst, c("a", "b", "c", "d"), value = 1, evaluate = TRUE,
  return_conventional = FALSE, strict = 1)
try(
  createCrudExpression(inst, c("a", "b", "c", "d"), value = 1, evaluate = TRUE,
  return_conventional = FALSE, strict = 2)
)
try(
  createCrudExpression(inst, c("a", "b", "c", "d"), value = 1, evaluate = TRUE,
  return_conventional = FALSE, strict = 3)
)
}
\author{
Janko Thyson \email{janko.thyson@rappster.de}
}
\references{
\url{http://github.com/rappster/crudr}
}
\seealso{
\code{\link[crudr]{createCrudExpression}}
}

